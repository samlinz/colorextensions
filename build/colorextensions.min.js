/*! colorextensions 1.0.0, built on Fri Sep 13 2019 11:49:03 GMT+0300 (Eastern European Summer Time) */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/colorextensions.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/colorextensions.js":
/*!********************************!*\
  !*** ./src/colorextensions.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

window.ColorExtensions = function () {
  var COLOR_TYPES = {
    Object: "object",
    HexShort: "hex_short",
    HexLong: "hex_long",
    RGB: "rgb"
  };
  var RGB_PROPERTIES = ["r", "g", "b"];
  var RGB_REGEX = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;

  function isRgbInValidRange(_int) {
    return _int >= 0 && _int <= 255;
  }

  alert('hello world!');

  function validateRgbObject(obj) {
    if (RGB_PROPERTIES.some(function (prop) {
      return !(prop in obj);
    })) throw Error("Object ".concat(JSON.stringify(obj), " does not include required properties"));
  }
  /**
   * Convert color as hex string to object with rgb integer properties.
   * @param {string} hex Color as hexadecimal string, short or long form.
   */


  function hexToObj(hex) {
    if (typeof hex !== "string") throw Error("".concat(hex, " is not string"));
    var hexStr = hex.slice(); // Remove the prefix if present.

    if (hexStr[0] === "#") hexStr = hexStr.substr(1);
    var hexLen = hexStr.length; // Check if the hex string is short or long form.

    var shortForm = null;
    if (hexLen === 3) shortForm = true;else if (hexLen === 6) shortForm = false;else throw Error("Invalid length for hex string ".concat(hexLen));
    var result = {
      r: null,
      g: null,
      b: null
    };
    var charsPerColor = shortForm ? 1 : 2;

    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var colorStr = hexStr.substr(0, charsPerColor);
      hexStr = hexStr.substr(charsPerColor);

      if (colorStr.length === 1) {
        colorStr = colorStr.repeat(2);
      }

      var colorInt = parseInt(colorStr, 16);

      if (Number.isNaN(colorInt)) {
        throw Error("Failed to convert string ".concat(colorStr, " to integer"));
      }

      result[key] = colorInt;
    }

    return result;
  }
  /**
   * Convert RGB object to hex string.
   *
   * @param {object} obj Object with r, g, b properties.
   * @param {object?} options
   */


  function objToHex(obj, options) {
    var optShortForm = options && options.shortForm;
    var optPrefix = options && options.prefix ? options.prefix : true;
    var result = optPrefix ? "#" : "";
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = RGB_PROPERTIES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var property = _step.value;
        var colorInt = +obj[property];
        if (!isRgbInValidRange(colorInt)) throw Error("Color is not valid rgb ".concat(colorInt));
        var colorHex = colorInt.toString(16);
        if (colorHex.length === 1) colorHex = "0".concat(colorHex);
        result += colorHex;
      } // Convert hex string to short form if possible.

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (optShortForm) {
      var hexWithoutPrefix = optPrefix ? result.substr(1) : result.slice();
      var resultShort = optPrefix ? "#" : "";

      for (var i = 0; i < 3; i++) {
        // Verify that color can be reprented in short form.
        if (hexWithoutPrefix[i * 2] !== hexWithoutPrefix[i * 2 + 1]) {
          resultShort = null;
          break;
        }

        resultShort += hexWithoutPrefix[i * 2];
      }

      result = resultShort || result;
    }

    return result;
  }
  /**
   * Convert RGB string to RGB object.
   * @param {string} rgb RGB string.
   */


  function rgbToObj(rgb) {
    var matches = RGB_REGEX.exec(rgb);
    if (!matches) throw Error("Could not parse rgb ".concat(rgb));
    if (matches.length !== 4) throw Error("Invalid number of matched groups");
    return {
      r: matches[1],
      g: matches[2],
      b: matches[3]
    };
  }
  /**
   * Convert RGB object to rgb string.
   * @param {object} obj RGB object.
   */


  function objToRgb(obj, options) {
    var optAlpha = options && options.alpha || null;
    validateRgbObject(obj);
    var prefix = optAlpha !== null ? "rgba" : "rgb";
    return "".concat(prefix, "(").concat(obj["r"], ",").concat(obj["g"], ",").concat(obj["b"]).concat(optAlpha ? ",".concat(optAlpha) : "", ")");
  }
  /**
   * Convert hex string to RGB string.
   * @param {string} hex Hex string.
   * @param {object?} options
   */


  function hexToRgb(hex, options) {
    return objToRgb(hexToObj(hex), options);
  }
  /**
   * Convert RGB string to hex string.
   * @param {string} rgb RGB string.
   * @param {object?} options
   */


  function rgbToHex(rgb, options) {
    return objToHex(rgbToObj(rgb), options);
  }

  function getColorType(value) {
    var isValidHexLenght = function isValidHexLenght(val) {
      return val.length === 3 || val.length === 6;
    };

    var handleHex = function handleHex(val) {
      if (val.length === 3) return COLOR_TYPES["HexShort"];
      if (val.length === 6) return COLOR_TYPES["HexLong"];
    }; // Check if value is object.-


    if (_typeof(value) === "object") {
      if (RGB_PROPERTIES.every(function (p) {
        return p in value;
      })) {
        return COLOR_TYPES["Object"];
      }

      throw Error("Value was object but was missing required properties");
    }

    if (typeof value !== "string") {
      throw Error("Value was not string");
    } // Check if hex starting with hash.


    if (value.startsWith("#")) {
      var colorValues = value.substr(1);

      if (!isValidHexLenght(colorValues)) {
        throw Error("Value started with hash but had invalid number of color values");
      }

      var _hexType = handleHex(colorValues);

      if (_hexType) return _hexType;
    } // Check if value is RGB.


    if (value.startsWith("rgb")) {
      if (!RGB_REGEX.test(value)) throw Error("Value started with rgb but had invalid form");
      return COLOR_TYPES["RGB"];
    } // Value has to be hex without prefix.


    var hexType = handleHex(value);
    if (hexType) return hexType;
    throw Error("Couldn't determine the color type of the value");
  }

  function convertTo(value, convertToType, options) {
    var type = getColorType(value);

    if (type.startsWith("hex")) {
      // Hex to rgb.
      if (convertToType === COLOR_TYPES["RGB"]) return hexToRgb(value, options); // Hex to object.

      if (convertToType === COLOR_TYPES["Object"]) return hexToObj(value); // Convert hex to hex.

      var obj = hexToObj(value);
      return objToHex(obj, {
        shortForm: convertToType === COLOR_TYPES["HexShort"]
      });
    }

    if (type === COLOR_TYPES["RGB"]) {
      // Rgb to hex.
      if (convertToType.startsWith("hex")) {
        return rgbToHex(value, {
          shortForm: convertToType === COLOR_TYPES["HexShort"]
        });
      } // Rgb to object.


      if (convertToType === COLOR_TYPES["Object"]) return rgbToObj(value); // Rgb to rgb.

      var _obj = rgbToObj(value);

      return objToRgb(_obj, options);
    }

    if (type === COLOR_TYPES["Object"]) {
      if (convertToType.startsWith("hex")) return objToHex(value, options);
      if (convertToType === COLOR_TYPES["RGB"]) return objToRgb(value);
      return value;
    }

    throw Error("Invalid type for the input value");
  }
  /**
   * Class which holds start and end color values and can produce any
   * color between those values.
   */


  var ColorInterpolator =
  /*#__PURE__*/
  function () {
    function ColorInterpolator(colormap) {
      _classCallCheck(this, ColorInterpolator);

      this.type = getColorType(start);
      this.start = convertTo(start, COLOR_TYPES["Object"]);
      this.stop = convertTo(stop, COLOR_TYPES["Object"]);
      this.rangeR = +this.stop["r"] - +this.start["r"];
      this.rangeG = +this.stop["g"] - +this.start["g"];
      this.rangeB = +this.stop["b"] - +this.start["b"];
    }
    /**
     * Return a color between the start and stop colors.
     *
     * @param {number} fraction Fraction between 0 and 1.
     * @param {string} type If present return the interpolated color in this format.
     */


    _createClass(ColorInterpolator, [{
      key: "getColor",
      value: function getColor(fraction) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof fraction !== "number") {
          throw Error("Invalid fraction ".concat(fraction));
        }

        if (fraction < 0 || fraction > 1) {
          throw Error("Fraction out of range ".concat(fraction));
        } // Calculate the new values between the provided start and end values.


        var r = +this.start["r"] + fraction * this.rangeR | 0;
        var g = +this.start["g"] + fraction * this.rangeG | 0;
        var b = +this.start["b"] + fraction * this.rangeB | 0;
        var colorObj = {
          r: r,
          g: g,
          b: b
        }; // Convert object to either the original or provided color type.

        return convertTo(colorObj, type || this.type);
      }
    }]);

    return ColorInterpolator;
  }();

  function interpolateColor(start, end, fraction) {
    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var interpolator = new ColorInterpolator(start, end);
    return interpolator.getColor(fraction, type);
  } // Return public API.


  return {
    hexToObj: hexToObj,
    objToHex: objToHex,
    objToRgb: objToRgb,
    hexToRgb: hexToRgb,
    rgbToHex: rgbToHex,
    convertTo: convertTo,
    ColorInterpolator: ColorInterpolator
  };
}();

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbG9yZXh0ZW5zaW9ucy5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJDb2xvckV4dGVuc2lvbnMiLCJDT0xPUl9UWVBFUyIsIk9iamVjdCIsIkhleFNob3J0IiwiSGV4TG9uZyIsIlJHQiIsIlJHQl9QUk9QRVJUSUVTIiwiUkdCX1JFR0VYIiwiaXNSZ2JJblZhbGlkUmFuZ2UiLCJpbnQiLCJhbGVydCIsInZhbGlkYXRlUmdiT2JqZWN0Iiwib2JqIiwic29tZSIsInByb3AiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZXhUb09iaiIsImhleCIsImhleFN0ciIsInNsaWNlIiwic3Vic3RyIiwiaGV4TGVuIiwibGVuZ3RoIiwic2hvcnRGb3JtIiwicmVzdWx0IiwiciIsImciLCJiIiwiY2hhcnNQZXJDb2xvciIsImtleXMiLCJrZXkiLCJjb2xvclN0ciIsInJlcGVhdCIsImNvbG9ySW50IiwicGFyc2VJbnQiLCJOdW1iZXIiLCJpc05hTiIsIm9ialRvSGV4Iiwib3B0aW9ucyIsIm9wdFNob3J0Rm9ybSIsIm9wdFByZWZpeCIsInByZWZpeCIsInByb3BlcnR5IiwiY29sb3JIZXgiLCJ0b1N0cmluZyIsImhleFdpdGhvdXRQcmVmaXgiLCJyZXN1bHRTaG9ydCIsImkiLCJyZ2JUb09iaiIsInJnYiIsIm1hdGNoZXMiLCJleGVjIiwib2JqVG9SZ2IiLCJvcHRBbHBoYSIsImFscGhhIiwiaGV4VG9SZ2IiLCJyZ2JUb0hleCIsImdldENvbG9yVHlwZSIsInZhbHVlIiwiaXNWYWxpZEhleExlbmdodCIsInZhbCIsImhhbmRsZUhleCIsImV2ZXJ5IiwicCIsInN0YXJ0c1dpdGgiLCJjb2xvclZhbHVlcyIsImhleFR5cGUiLCJ0ZXN0IiwiY29udmVydFRvIiwiY29udmVydFRvVHlwZSIsInR5cGUiLCJDb2xvckludGVycG9sYXRvciIsImNvbG9ybWFwIiwic3RhcnQiLCJzdG9wIiwicmFuZ2VSIiwicmFuZ2VHIiwicmFuZ2VCIiwiZnJhY3Rpb24iLCJjb2xvck9iaiIsImludGVycG9sYXRlQ29sb3IiLCJlbmQiLCJpbnRlcnBvbGF0b3IiLCJnZXRDb2xvciJdLCJtYXBwaW5ncyI6Ijs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBQSxNQUFNLENBQUNDLGVBQVAsR0FBMEIsWUFBVztBQUNqQyxNQUFNQyxXQUFXLEdBQUc7QUFDaEJDLFVBQU0sRUFBRSxRQURRO0FBRWhCQyxZQUFRLEVBQUUsV0FGTTtBQUdoQkMsV0FBTyxFQUFFLFVBSE87QUFJaEJDLE9BQUcsRUFBRTtBQUpXLEdBQXBCO0FBT0EsTUFBTUMsY0FBYyxHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBQXZCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLDhDQUFsQjs7QUFFQSxXQUFTQyxpQkFBVCxDQUEyQkMsSUFBM0IsRUFBZ0M7QUFDNUIsV0FBT0EsSUFBRyxJQUFJLENBQVAsSUFBWUEsSUFBRyxJQUFJLEdBQTFCO0FBQ0g7O0FBRURDLE9BQUssQ0FBQyxjQUFELENBQUw7O0FBRUEsV0FBU0MsaUJBQVQsQ0FBMkJDLEdBQTNCLEVBQWdDO0FBQzVCLFFBQUlOLGNBQWMsQ0FBQ08sSUFBZixDQUFvQixVQUFBQyxJQUFJO0FBQUEsYUFBSSxFQUFFQSxJQUFJLElBQUlGLEdBQVYsQ0FBSjtBQUFBLEtBQXhCLENBQUosRUFDSSxNQUFNRyxLQUFLLGtCQUNHQyxJQUFJLENBQUNDLFNBQUwsQ0FDTkwsR0FETSxDQURILDJDQUFYO0FBS1A7QUFFRDs7Ozs7O0FBSUEsV0FBU00sUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDbkIsUUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkIsTUFBTUosS0FBSyxXQUFJSSxHQUFKLG9CQUFYO0FBRTdCLFFBQUlDLE1BQU0sR0FBR0QsR0FBRyxDQUFDRSxLQUFKLEVBQWIsQ0FIbUIsQ0FLbkI7O0FBQ0EsUUFBSUQsTUFBTSxDQUFDLENBQUQsQ0FBTixLQUFjLEdBQWxCLEVBQXVCQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0UsTUFBUCxDQUFjLENBQWQsQ0FBVDtBQUV2QixRQUFNQyxNQUFNLEdBQUdILE1BQU0sQ0FBQ0ksTUFBdEIsQ0FSbUIsQ0FVbkI7O0FBQ0EsUUFBSUMsU0FBUyxHQUFHLElBQWhCO0FBQ0EsUUFBSUYsTUFBTSxLQUFLLENBQWYsRUFBa0JFLFNBQVMsR0FBRyxJQUFaLENBQWxCLEtBQ0ssSUFBSUYsTUFBTSxLQUFLLENBQWYsRUFBa0JFLFNBQVMsR0FBRyxLQUFaLENBQWxCLEtBQ0EsTUFBTVYsS0FBSyx5Q0FBa0NRLE1BQWxDLEVBQVg7QUFFTCxRQUFNRyxNQUFNLEdBQUc7QUFDWEMsT0FBQyxFQUFFLElBRFE7QUFFWEMsT0FBQyxFQUFFLElBRlE7QUFHWEMsT0FBQyxFQUFFO0FBSFEsS0FBZjtBQU1BLFFBQU1DLGFBQWEsR0FBR0wsU0FBUyxHQUFHLENBQUgsR0FBTyxDQUF0Qzs7QUFDQSxvQ0FBa0J2QixNQUFNLENBQUM2QixJQUFQLENBQVlMLE1BQVosQ0FBbEIsa0NBQXVDO0FBQWxDLFVBQU1NLEdBQUcsbUJBQVQ7QUFDRCxVQUFJQyxRQUFRLEdBQUdiLE1BQU0sQ0FBQ0UsTUFBUCxDQUFjLENBQWQsRUFBaUJRLGFBQWpCLENBQWY7QUFDQVYsWUFBTSxHQUFHQSxNQUFNLENBQUNFLE1BQVAsQ0FBY1EsYUFBZCxDQUFUOztBQUNBLFVBQUlHLFFBQVEsQ0FBQ1QsTUFBVCxLQUFvQixDQUF4QixFQUEyQjtBQUN2QlMsZ0JBQVEsR0FBR0EsUUFBUSxDQUFDQyxNQUFULENBQWdCLENBQWhCLENBQVg7QUFDSDs7QUFDRCxVQUFNQyxRQUFRLEdBQUdDLFFBQVEsQ0FBQ0gsUUFBRCxFQUFXLEVBQVgsQ0FBekI7O0FBQ0EsVUFBSUksTUFBTSxDQUFDQyxLQUFQLENBQWFILFFBQWIsQ0FBSixFQUE0QjtBQUN4QixjQUFNcEIsS0FBSyxvQ0FBNkJrQixRQUE3QixpQkFBWDtBQUNIOztBQUNEUCxZQUFNLENBQUNNLEdBQUQsQ0FBTixHQUFjRyxRQUFkO0FBQ0g7O0FBRUQsV0FBT1QsTUFBUDtBQUNIO0FBRUQ7Ozs7Ozs7O0FBTUEsV0FBU2EsUUFBVCxDQUFrQjNCLEdBQWxCLEVBQXVCNEIsT0FBdkIsRUFBZ0M7QUFDNUIsUUFBTUMsWUFBWSxHQUFHRCxPQUFPLElBQUlBLE9BQU8sQ0FBQ2YsU0FBeEM7QUFDQSxRQUFNaUIsU0FBUyxHQUFHRixPQUFPLElBQUlBLE9BQU8sQ0FBQ0csTUFBbkIsR0FBNEJILE9BQU8sQ0FBQ0csTUFBcEMsR0FBNkMsSUFBL0Q7QUFFQSxRQUFJakIsTUFBTSxHQUFHZ0IsU0FBUyxHQUFHLEdBQUgsR0FBUyxFQUEvQjtBQUo0QjtBQUFBO0FBQUE7O0FBQUE7QUFLNUIsMkJBQXVCcEMsY0FBdkIsOEhBQXVDO0FBQUEsWUFBNUJzQyxRQUE0QjtBQUNuQyxZQUFNVCxRQUFRLEdBQUcsQ0FBQ3ZCLEdBQUcsQ0FBQ2dDLFFBQUQsQ0FBckI7QUFDQSxZQUFJLENBQUNwQyxpQkFBaUIsQ0FBQzJCLFFBQUQsQ0FBdEIsRUFDSSxNQUFNcEIsS0FBSyxrQ0FBMkJvQixRQUEzQixFQUFYO0FBRUosWUFBSVUsUUFBUSxHQUFHVixRQUFRLENBQUNXLFFBQVQsQ0FBa0IsRUFBbEIsQ0FBZjtBQUNBLFlBQUlELFFBQVEsQ0FBQ3JCLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkJxQixRQUFRLGNBQU9BLFFBQVAsQ0FBUjtBQUMzQm5CLGNBQU0sSUFBSW1CLFFBQVY7QUFDSCxPQWIyQixDQWU1Qjs7QUFmNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQjVCLFFBQUlKLFlBQUosRUFBa0I7QUFDZCxVQUFNTSxnQkFBZ0IsR0FBR0wsU0FBUyxHQUM1QmhCLE1BQU0sQ0FBQ0osTUFBUCxDQUFjLENBQWQsQ0FENEIsR0FFNUJJLE1BQU0sQ0FBQ0wsS0FBUCxFQUZOO0FBR0EsVUFBSTJCLFdBQVcsR0FBR04sU0FBUyxHQUFHLEdBQUgsR0FBUyxFQUFwQzs7QUFFQSxXQUFLLElBQUlPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDeEI7QUFDQSxZQUFJRixnQkFBZ0IsQ0FBQ0UsQ0FBQyxHQUFHLENBQUwsQ0FBaEIsS0FBNEJGLGdCQUFnQixDQUFDRSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQsQ0FBaEQsRUFBNkQ7QUFDekRELHFCQUFXLEdBQUcsSUFBZDtBQUNBO0FBQ0g7O0FBQ0RBLG1CQUFXLElBQUlELGdCQUFnQixDQUFDRSxDQUFDLEdBQUcsQ0FBTCxDQUEvQjtBQUNIOztBQUVEdkIsWUFBTSxHQUFHc0IsV0FBVyxJQUFJdEIsTUFBeEI7QUFDSDs7QUFFRCxXQUFPQSxNQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBSUEsV0FBU3dCLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ25CLFFBQU1DLE9BQU8sR0FBRzdDLFNBQVMsQ0FBQzhDLElBQVYsQ0FBZUYsR0FBZixDQUFoQjtBQUNBLFFBQUksQ0FBQ0MsT0FBTCxFQUFjLE1BQU1yQyxLQUFLLCtCQUF3Qm9DLEdBQXhCLEVBQVg7QUFDZCxRQUFJQyxPQUFPLENBQUM1QixNQUFSLEtBQW1CLENBQXZCLEVBQ0ksTUFBTVQsS0FBSyxvQ0FBWDtBQUNKLFdBQU87QUFDSFksT0FBQyxFQUFFeUIsT0FBTyxDQUFDLENBQUQsQ0FEUDtBQUVIeEIsT0FBQyxFQUFFd0IsT0FBTyxDQUFDLENBQUQsQ0FGUDtBQUdIdkIsT0FBQyxFQUFFdUIsT0FBTyxDQUFDLENBQUQ7QUFIUCxLQUFQO0FBS0g7QUFFRDs7Ozs7O0FBSUEsV0FBU0UsUUFBVCxDQUFrQjFDLEdBQWxCLEVBQXVCNEIsT0FBdkIsRUFBZ0M7QUFDNUIsUUFBTWUsUUFBUSxHQUFJZixPQUFPLElBQUlBLE9BQU8sQ0FBQ2dCLEtBQXBCLElBQThCLElBQS9DO0FBRUE3QyxxQkFBaUIsQ0FBQ0MsR0FBRCxDQUFqQjtBQUNBLFFBQU0rQixNQUFNLEdBQUdZLFFBQVEsS0FBSyxJQUFiLEdBQW9CLE1BQXBCLEdBQTZCLEtBQTVDO0FBQ0EscUJBQVVaLE1BQVYsY0FBb0IvQixHQUFHLENBQUMsR0FBRCxDQUF2QixjQUFnQ0EsR0FBRyxDQUFDLEdBQUQsQ0FBbkMsY0FBNENBLEdBQUcsQ0FBQyxHQUFELENBQS9DLFNBQ0kyQyxRQUFRLGNBQU9BLFFBQVAsSUFBb0IsRUFEaEM7QUFHSDtBQUVEOzs7Ozs7O0FBS0EsV0FBU0UsUUFBVCxDQUFrQnRDLEdBQWxCLEVBQXVCcUIsT0FBdkIsRUFBZ0M7QUFDNUIsV0FBT2MsUUFBUSxDQUFDcEMsUUFBUSxDQUFDQyxHQUFELENBQVQsRUFBZ0JxQixPQUFoQixDQUFmO0FBQ0g7QUFFRDs7Ozs7OztBQUtBLFdBQVNrQixRQUFULENBQWtCUCxHQUFsQixFQUF1QlgsT0FBdkIsRUFBZ0M7QUFDNUIsV0FBT0QsUUFBUSxDQUFDVyxRQUFRLENBQUNDLEdBQUQsQ0FBVCxFQUFnQlgsT0FBaEIsQ0FBZjtBQUNIOztBQUVELFdBQVNtQixZQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUN6QixRQUFNQyxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQUFDLEdBQUc7QUFBQSxhQUFJQSxHQUFHLENBQUN0QyxNQUFKLEtBQWUsQ0FBZixJQUFvQnNDLEdBQUcsQ0FBQ3RDLE1BQUosS0FBZSxDQUF2QztBQUFBLEtBQTVCOztBQUNBLFFBQU11QyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFBRCxHQUFHLEVBQUk7QUFDckIsVUFBSUEsR0FBRyxDQUFDdEMsTUFBSixLQUFlLENBQW5CLEVBQXNCLE9BQU92QixXQUFXLENBQUMsVUFBRCxDQUFsQjtBQUN0QixVQUFJNkQsR0FBRyxDQUFDdEMsTUFBSixLQUFlLENBQW5CLEVBQXNCLE9BQU92QixXQUFXLENBQUMsU0FBRCxDQUFsQjtBQUN6QixLQUhELENBRnlCLENBT3pCOzs7QUFDQSxRQUFJLFFBQU8yRCxLQUFQLE1BQWlCLFFBQXJCLEVBQStCO0FBQzNCLFVBQUl0RCxjQUFjLENBQUMwRCxLQUFmLENBQXFCLFVBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLElBQUlMLEtBQVQ7QUFBQSxPQUF0QixDQUFKLEVBQTJDO0FBQ3ZDLGVBQU8zRCxXQUFXLENBQUMsUUFBRCxDQUFsQjtBQUNIOztBQUNELFlBQU1jLEtBQUssQ0FBQyxzREFBRCxDQUFYO0FBQ0g7O0FBRUQsUUFBSSxPQUFPNkMsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQixZQUFNN0MsS0FBSyxDQUFDLHNCQUFELENBQVg7QUFDSCxLQWpCd0IsQ0FtQnpCOzs7QUFDQSxRQUFJNkMsS0FBSyxDQUFDTSxVQUFOLENBQWlCLEdBQWpCLENBQUosRUFBMkI7QUFDdkIsVUFBTUMsV0FBVyxHQUFHUCxLQUFLLENBQUN0QyxNQUFOLENBQWEsQ0FBYixDQUFwQjs7QUFDQSxVQUFJLENBQUN1QyxnQkFBZ0IsQ0FBQ00sV0FBRCxDQUFyQixFQUFvQztBQUNoQyxjQUFNcEQsS0FBSyxDQUNQLGdFQURPLENBQVg7QUFHSDs7QUFFRCxVQUFNcUQsUUFBTyxHQUFHTCxTQUFTLENBQUNJLFdBQUQsQ0FBekI7O0FBQ0EsVUFBSUMsUUFBSixFQUFhLE9BQU9BLFFBQVA7QUFDaEIsS0E5QndCLENBZ0N6Qjs7O0FBQ0EsUUFBSVIsS0FBSyxDQUFDTSxVQUFOLENBQWlCLEtBQWpCLENBQUosRUFBNkI7QUFDekIsVUFBSSxDQUFDM0QsU0FBUyxDQUFDOEQsSUFBVixDQUFlVCxLQUFmLENBQUwsRUFDSSxNQUFNN0MsS0FBSyxDQUFDLDZDQUFELENBQVg7QUFFSixhQUFPZCxXQUFXLENBQUMsS0FBRCxDQUFsQjtBQUNILEtBdEN3QixDQXdDekI7OztBQUNBLFFBQU1tRSxPQUFPLEdBQUdMLFNBQVMsQ0FBQ0gsS0FBRCxDQUF6QjtBQUNBLFFBQUlRLE9BQUosRUFBYSxPQUFPQSxPQUFQO0FBRWIsVUFBTXJELEtBQUssQ0FBQyxnREFBRCxDQUFYO0FBQ0g7O0FBRUQsV0FBU3VELFNBQVQsQ0FBbUJWLEtBQW5CLEVBQTBCVyxhQUExQixFQUF5Qy9CLE9BQXpDLEVBQWtEO0FBQzlDLFFBQU1nQyxJQUFJLEdBQUdiLFlBQVksQ0FBQ0MsS0FBRCxDQUF6Qjs7QUFFQSxRQUFJWSxJQUFJLENBQUNOLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBSixFQUE0QjtBQUN4QjtBQUNBLFVBQUlLLGFBQWEsS0FBS3RFLFdBQVcsQ0FBQyxLQUFELENBQWpDLEVBQ0ksT0FBT3dELFFBQVEsQ0FBQ0csS0FBRCxFQUFRcEIsT0FBUixDQUFmLENBSG9CLENBS3hCOztBQUNBLFVBQUkrQixhQUFhLEtBQUt0RSxXQUFXLENBQUMsUUFBRCxDQUFqQyxFQUE2QyxPQUFPaUIsUUFBUSxDQUFDMEMsS0FBRCxDQUFmLENBTnJCLENBUXhCOztBQUNBLFVBQU1oRCxHQUFHLEdBQUdNLFFBQVEsQ0FBQzBDLEtBQUQsQ0FBcEI7QUFDQSxhQUFPckIsUUFBUSxDQUFDM0IsR0FBRCxFQUFNO0FBQ2pCYSxpQkFBUyxFQUFFOEMsYUFBYSxLQUFLdEUsV0FBVyxDQUFDLFVBQUQ7QUFEdkIsT0FBTixDQUFmO0FBR0g7O0FBRUQsUUFBSXVFLElBQUksS0FBS3ZFLFdBQVcsQ0FBQyxLQUFELENBQXhCLEVBQWlDO0FBQzdCO0FBQ0EsVUFBSXNFLGFBQWEsQ0FBQ0wsVUFBZCxDQUF5QixLQUF6QixDQUFKLEVBQXFDO0FBQ2pDLGVBQU9SLFFBQVEsQ0FBQ0UsS0FBRCxFQUFRO0FBQ25CbkMsbUJBQVMsRUFBRThDLGFBQWEsS0FBS3RFLFdBQVcsQ0FBQyxVQUFEO0FBRHJCLFNBQVIsQ0FBZjtBQUdILE9BTjRCLENBTzdCOzs7QUFDQSxVQUFJc0UsYUFBYSxLQUFLdEUsV0FBVyxDQUFDLFFBQUQsQ0FBakMsRUFBNkMsT0FBT2lELFFBQVEsQ0FBQ1UsS0FBRCxDQUFmLENBUmhCLENBVTdCOztBQUNBLFVBQU1oRCxJQUFHLEdBQUdzQyxRQUFRLENBQUNVLEtBQUQsQ0FBcEI7O0FBQ0EsYUFBT04sUUFBUSxDQUFDMUMsSUFBRCxFQUFNNEIsT0FBTixDQUFmO0FBQ0g7O0FBRUQsUUFBSWdDLElBQUksS0FBS3ZFLFdBQVcsQ0FBQyxRQUFELENBQXhCLEVBQW9DO0FBQ2hDLFVBQUlzRSxhQUFhLENBQUNMLFVBQWQsQ0FBeUIsS0FBekIsQ0FBSixFQUNJLE9BQU8zQixRQUFRLENBQUNxQixLQUFELEVBQVFwQixPQUFSLENBQWY7QUFDSixVQUFJK0IsYUFBYSxLQUFLdEUsV0FBVyxDQUFDLEtBQUQsQ0FBakMsRUFBMEMsT0FBT3FELFFBQVEsQ0FBQ00sS0FBRCxDQUFmO0FBQzFDLGFBQU9BLEtBQVA7QUFDSDs7QUFFRCxVQUFNN0MsS0FBSyxDQUFDLGtDQUFELENBQVg7QUFDSDtBQUVEOzs7Ozs7QUExUGlDLE1BOFAzQjBELGlCQTlQMkI7QUFBQTtBQUFBO0FBK1A3QiwrQkFBWUMsUUFBWixFQUFzQjtBQUFBOztBQUNsQixXQUFLRixJQUFMLEdBQVliLFlBQVksQ0FBQ2dCLEtBQUQsQ0FBeEI7QUFFQSxXQUFLQSxLQUFMLEdBQWFMLFNBQVMsQ0FBQ0ssS0FBRCxFQUFRMUUsV0FBVyxDQUFDLFFBQUQsQ0FBbkIsQ0FBdEI7QUFDQSxXQUFLMkUsSUFBTCxHQUFZTixTQUFTLENBQUNNLElBQUQsRUFBTzNFLFdBQVcsQ0FBQyxRQUFELENBQWxCLENBQXJCO0FBRUEsV0FBSzRFLE1BQUwsR0FBYyxDQUFDLEtBQUtELElBQUwsQ0FBVSxHQUFWLENBQUQsR0FBa0IsQ0FBQyxLQUFLRCxLQUFMLENBQVcsR0FBWCxDQUFqQztBQUNBLFdBQUtHLE1BQUwsR0FBYyxDQUFDLEtBQUtGLElBQUwsQ0FBVSxHQUFWLENBQUQsR0FBa0IsQ0FBQyxLQUFLRCxLQUFMLENBQVcsR0FBWCxDQUFqQztBQUNBLFdBQUtJLE1BQUwsR0FBYyxDQUFDLEtBQUtILElBQUwsQ0FBVSxHQUFWLENBQUQsR0FBa0IsQ0FBQyxLQUFLRCxLQUFMLENBQVcsR0FBWCxDQUFqQztBQUNIO0FBRUQ7Ozs7Ozs7O0FBMVE2QjtBQUFBO0FBQUEsK0JBZ1JwQkssUUFoUm9CLEVBZ1JHO0FBQUEsWUFBYlIsSUFBYSx1RUFBTixJQUFNOztBQUM1QixZQUFJLE9BQU9RLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDOUIsZ0JBQU1qRSxLQUFLLDRCQUFxQmlFLFFBQXJCLEVBQVg7QUFDSDs7QUFDRCxZQUFJQSxRQUFRLEdBQUcsQ0FBWCxJQUFnQkEsUUFBUSxHQUFHLENBQS9CLEVBQWtDO0FBQzlCLGdCQUFNakUsS0FBSyxpQ0FBMEJpRSxRQUExQixFQUFYO0FBQ0gsU0FOMkIsQ0FRNUI7OztBQUNBLFlBQU1yRCxDQUFDLEdBQUksQ0FBQyxLQUFLZ0QsS0FBTCxDQUFXLEdBQVgsQ0FBRCxHQUFtQkssUUFBUSxHQUFHLEtBQUtILE1BQXBDLEdBQThDLENBQXhEO0FBQ0EsWUFBTWpELENBQUMsR0FBSSxDQUFDLEtBQUsrQyxLQUFMLENBQVcsR0FBWCxDQUFELEdBQW1CSyxRQUFRLEdBQUcsS0FBS0YsTUFBcEMsR0FBOEMsQ0FBeEQ7QUFDQSxZQUFNakQsQ0FBQyxHQUFJLENBQUMsS0FBSzhDLEtBQUwsQ0FBVyxHQUFYLENBQUQsR0FBbUJLLFFBQVEsR0FBRyxLQUFLRCxNQUFwQyxHQUE4QyxDQUF4RDtBQUVBLFlBQU1FLFFBQVEsR0FBRztBQUNidEQsV0FBQyxFQUFEQSxDQURhO0FBRWJDLFdBQUMsRUFBREEsQ0FGYTtBQUdiQyxXQUFDLEVBQURBO0FBSGEsU0FBakIsQ0FiNEIsQ0FtQjVCOztBQUNBLGVBQU95QyxTQUFTLENBQUNXLFFBQUQsRUFBV1QsSUFBSSxJQUFJLEtBQUtBLElBQXhCLENBQWhCO0FBQ0g7QUFyUzRCOztBQUFBO0FBQUE7O0FBd1NqQyxXQUFTVSxnQkFBVCxDQUEwQlAsS0FBMUIsRUFBaUNRLEdBQWpDLEVBQXNDSCxRQUF0QyxFQUEyRDtBQUFBLFFBQVhSLElBQVcsdUVBQU4sSUFBTTtBQUN2RCxRQUFNWSxZQUFZLEdBQUcsSUFBSVgsaUJBQUosQ0FBc0JFLEtBQXRCLEVBQTZCUSxHQUE3QixDQUFyQjtBQUNBLFdBQU9DLFlBQVksQ0FBQ0MsUUFBYixDQUFzQkwsUUFBdEIsRUFBZ0NSLElBQWhDLENBQVA7QUFDSCxHQTNTZ0MsQ0E2U2pDOzs7QUFDQSxTQUFPO0FBQ0h0RCxZQUFRLEVBQVJBLFFBREc7QUFFSHFCLFlBQVEsRUFBUkEsUUFGRztBQUdIZSxZQUFRLEVBQVJBLFFBSEc7QUFJSEcsWUFBUSxFQUFSQSxRQUpHO0FBS0hDLFlBQVEsRUFBUkEsUUFMRztBQU1IWSxhQUFTLEVBQVRBLFNBTkc7QUFPSEcscUJBQWlCLEVBQWpCQTtBQVBHLEdBQVA7QUFTSCxDQXZUd0IsRUFBekIsQyIsImZpbGUiOiJjb2xvcmV4dGVuc2lvbnMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvY29sb3JleHRlbnNpb25zLmpzXCIpO1xuIiwid2luZG93LkNvbG9yRXh0ZW5zaW9ucyA9IChmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IENPTE9SX1RZUEVTID0ge1xyXG4gICAgICAgIE9iamVjdDogXCJvYmplY3RcIixcclxuICAgICAgICBIZXhTaG9ydDogXCJoZXhfc2hvcnRcIixcclxuICAgICAgICBIZXhMb25nOiBcImhleF9sb25nXCIsXHJcbiAgICAgICAgUkdCOiBcInJnYlwiXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IFJHQl9QUk9QRVJUSUVTID0gW1wiclwiLCBcImdcIiwgXCJiXCJdO1xyXG4gICAgY29uc3QgUkdCX1JFR0VYID0gL3JnYmE/XFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXCkvO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzUmdiSW5WYWxpZFJhbmdlKGludCkge1xyXG4gICAgICAgIHJldHVybiBpbnQgPj0gMCAmJiBpbnQgPD0gMjU1O1xyXG4gICAgfVxyXG5cclxuICAgIGFsZXJ0KCdoZWxsbyB3b3JsZCEnKVxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUmdiT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGlmIChSR0JfUFJPUEVSVElFUy5zb21lKHByb3AgPT4gIShwcm9wIGluIG9iaikpKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcclxuICAgICAgICAgICAgICAgIGBPYmplY3QgJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgICAgICAgICBvYmpcclxuICAgICAgICAgICAgICAgICl9IGRvZXMgbm90IGluY2x1ZGUgcmVxdWlyZWQgcHJvcGVydGllc2BcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgY29sb3IgYXMgaGV4IHN0cmluZyB0byBvYmplY3Qgd2l0aCByZ2IgaW50ZWdlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleCBDb2xvciBhcyBoZXhhZGVjaW1hbCBzdHJpbmcsIHNob3J0IG9yIGxvbmcgZm9ybS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGV4VG9PYmooaGV4KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09IFwic3RyaW5nXCIpIHRocm93IEVycm9yKGAke2hleH0gaXMgbm90IHN0cmluZ2ApO1xyXG5cclxuICAgICAgICBsZXQgaGV4U3RyID0gaGV4LnNsaWNlKCk7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJlZml4IGlmIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKGhleFN0clswXSA9PT0gXCIjXCIpIGhleFN0ciA9IGhleFN0ci5zdWJzdHIoMSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGhleExlbiA9IGhleFN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBoZXggc3RyaW5nIGlzIHNob3J0IG9yIGxvbmcgZm9ybS5cclxuICAgICAgICBsZXQgc2hvcnRGb3JtID0gbnVsbDtcclxuICAgICAgICBpZiAoaGV4TGVuID09PSAzKSBzaG9ydEZvcm0gPSB0cnVlO1xyXG4gICAgICAgIGVsc2UgaWYgKGhleExlbiA9PT0gNikgc2hvcnRGb3JtID0gZmFsc2U7XHJcbiAgICAgICAgZWxzZSB0aHJvdyBFcnJvcihgSW52YWxpZCBsZW5ndGggZm9yIGhleCBzdHJpbmcgJHtoZXhMZW59YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgcjogbnVsbCxcclxuICAgICAgICAgICAgZzogbnVsbCxcclxuICAgICAgICAgICAgYjogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGNoYXJzUGVyQ29sb3IgPSBzaG9ydEZvcm0gPyAxIDogMjtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGxldCBjb2xvclN0ciA9IGhleFN0ci5zdWJzdHIoMCwgY2hhcnNQZXJDb2xvcik7XHJcbiAgICAgICAgICAgIGhleFN0ciA9IGhleFN0ci5zdWJzdHIoY2hhcnNQZXJDb2xvcik7XHJcbiAgICAgICAgICAgIGlmIChjb2xvclN0ci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yU3RyID0gY29sb3JTdHIucmVwZWF0KDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ySW50ID0gcGFyc2VJbnQoY29sb3JTdHIsIDE2KTtcclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihjb2xvckludCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCBzdHJpbmcgJHtjb2xvclN0cn0gdG8gaW50ZWdlcmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29sb3JJbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBSR0Igb2JqZWN0IHRvIGhleCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3Qgd2l0aCByLCBnLCBiIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb2JqVG9IZXgob2JqLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0U2hvcnRGb3JtID0gb3B0aW9ucyAmJiBvcHRpb25zLnNob3J0Rm9ybTtcclxuICAgICAgICBjb25zdCBvcHRQcmVmaXggPSBvcHRpb25zICYmIG9wdGlvbnMucHJlZml4ID8gb3B0aW9ucy5wcmVmaXggOiB0cnVlO1xyXG5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gb3B0UHJlZml4ID8gXCIjXCIgOiBcIlwiO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgUkdCX1BST1BFUlRJRVMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JJbnQgPSArb2JqW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgaWYgKCFpc1JnYkluVmFsaWRSYW5nZShjb2xvckludCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29sb3IgaXMgbm90IHZhbGlkIHJnYiAke2NvbG9ySW50fWApO1xyXG5cclxuICAgICAgICAgICAgbGV0IGNvbG9ySGV4ID0gY29sb3JJbnQudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICBpZiAoY29sb3JIZXgubGVuZ3RoID09PSAxKSBjb2xvckhleCA9IGAwJHtjb2xvckhleH1gO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gY29sb3JIZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gc2hvcnQgZm9ybSBpZiBwb3NzaWJsZS5cclxuICAgICAgICBpZiAob3B0U2hvcnRGb3JtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSBvcHRQcmVmaXhcclxuICAgICAgICAgICAgICAgID8gcmVzdWx0LnN1YnN0cigxKVxyXG4gICAgICAgICAgICAgICAgOiByZXN1bHQuc2xpY2UoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdFNob3J0ID0gb3B0UHJlZml4ID8gXCIjXCIgOiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGNvbG9yIGNhbiBiZSByZXByZW50ZWQgaW4gc2hvcnQgZm9ybS5cclxuICAgICAgICAgICAgICAgIGlmIChoZXhXaXRob3V0UHJlZml4W2kgKiAyXSAhPT0gaGV4V2l0aG91dFByZWZpeFtpICogMiArIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2hvcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0U2hvcnQgKz0gaGV4V2l0aG91dFByZWZpeFtpICogMl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNob3J0IHx8IHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IFJHQiBzdHJpbmcgdG8gUkdCIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZ2IgUkdCIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmdiVG9PYmoocmdiKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJHQl9SRUdFWC5leGVjKHJnYik7XHJcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB0aHJvdyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHJnYiAke3JnYn1gKTtcclxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggIT09IDQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBtYXRjaGVkIGdyb3Vwc2ApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHI6IG1hdGNoZXNbMV0sXHJcbiAgICAgICAgICAgIGc6IG1hdGNoZXNbMl0sXHJcbiAgICAgICAgICAgIGI6IG1hdGNoZXNbM11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBSR0Igb2JqZWN0IHRvIHJnYiBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIFJHQiBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9ialRvUmdiKG9iaiwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9wdEFscGhhID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbHBoYSkgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgdmFsaWRhdGVSZ2JPYmplY3Qob2JqKTtcclxuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRBbHBoYSAhPT0gbnVsbCA/IFwicmdiYVwiIDogXCJyZ2JcIjtcclxuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSgke29ialtcInJcIl19LCR7b2JqW1wiZ1wiXX0sJHtvYmpbXCJiXCJdfSR7XHJcbiAgICAgICAgICAgIG9wdEFscGhhID8gYCwke29wdEFscGhhfWAgOiBcIlwiXHJcbiAgICAgICAgfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBoZXggc3RyaW5nIHRvIFJHQiBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IEhleCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGV4VG9SZ2IoaGV4LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialRvUmdiKGhleFRvT2JqKGhleCksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBSR0Igc3RyaW5nIHRvIGhleCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmdiIFJHQiBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmdiVG9IZXgocmdiLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialRvSGV4KHJnYlRvT2JqKHJnYiksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbG9yVHlwZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWRIZXhMZW5naHQgPSB2YWwgPT4gdmFsLmxlbmd0aCA9PT0gMyB8fCB2YWwubGVuZ3RoID09PSA2O1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZUhleCA9IHZhbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAzKSByZXR1cm4gQ09MT1JfVFlQRVNbXCJIZXhTaG9ydFwiXTtcclxuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDYpIHJldHVybiBDT0xPUl9UWVBFU1tcIkhleExvbmdcIl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgb2JqZWN0Li1cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmIChSR0JfUFJPUEVSVElFUy5ldmVyeShwID0+IHAgaW4gdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09MT1JfVFlQRVNbXCJPYmplY3RcIl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJWYWx1ZSB3YXMgb2JqZWN0IGJ1dCB3YXMgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlZhbHVlIHdhcyBub3Qgc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgaGV4IHN0YXJ0aW5nIHdpdGggaGFzaC5cclxuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcIiNcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JWYWx1ZXMgPSB2YWx1ZS5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZEhleExlbmdodChjb2xvclZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVmFsdWUgc3RhcnRlZCB3aXRoIGhhc2ggYnV0IGhhZCBpbnZhbGlkIG51bWJlciBvZiBjb2xvciB2YWx1ZXNcIlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaGV4VHlwZSA9IGhhbmRsZUhleChjb2xvclZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmIChoZXhUeXBlKSByZXR1cm4gaGV4VHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIFJHQi5cclxuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcInJnYlwiKSkge1xyXG4gICAgICAgICAgICBpZiAoIVJHQl9SRUdFWC50ZXN0KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVmFsdWUgc3RhcnRlZCB3aXRoIHJnYiBidXQgaGFkIGludmFsaWQgZm9ybVwiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDT0xPUl9UWVBFU1tcIlJHQlwiXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZhbHVlIGhhcyB0byBiZSBoZXggd2l0aG91dCBwcmVmaXguXHJcbiAgICAgICAgY29uc3QgaGV4VHlwZSA9IGhhbmRsZUhleCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGhleFR5cGUpIHJldHVybiBoZXhUeXBlO1xyXG5cclxuICAgICAgICB0aHJvdyBFcnJvcihcIkNvdWxkbid0IGRldGVybWluZSB0aGUgY29sb3IgdHlwZSBvZiB0aGUgdmFsdWVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udmVydFRvKHZhbHVlLCBjb252ZXJ0VG9UeXBlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldENvbG9yVHlwZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoXCJoZXhcIikpIHtcclxuICAgICAgICAgICAgLy8gSGV4IHRvIHJnYi5cclxuICAgICAgICAgICAgaWYgKGNvbnZlcnRUb1R5cGUgPT09IENPTE9SX1RZUEVTW1wiUkdCXCJdKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiKHZhbHVlLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhleCB0byBvYmplY3QuXHJcbiAgICAgICAgICAgIGlmIChjb252ZXJ0VG9UeXBlID09PSBDT0xPUl9UWVBFU1tcIk9iamVjdFwiXSkgcmV0dXJuIGhleFRvT2JqKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgaGV4IHRvIGhleC5cclxuICAgICAgICAgICAgY29uc3Qgb2JqID0gaGV4VG9PYmoodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqVG9IZXgob2JqLCB7XHJcbiAgICAgICAgICAgICAgICBzaG9ydEZvcm06IGNvbnZlcnRUb1R5cGUgPT09IENPTE9SX1RZUEVTW1wiSGV4U2hvcnRcIl1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZSA9PT0gQ09MT1JfVFlQRVNbXCJSR0JcIl0pIHtcclxuICAgICAgICAgICAgLy8gUmdiIHRvIGhleC5cclxuICAgICAgICAgICAgaWYgKGNvbnZlcnRUb1R5cGUuc3RhcnRzV2l0aChcImhleFwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYlRvSGV4KHZhbHVlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRGb3JtOiBjb252ZXJ0VG9UeXBlID09PSBDT0xPUl9UWVBFU1tcIkhleFNob3J0XCJdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZ2IgdG8gb2JqZWN0LlxyXG4gICAgICAgICAgICBpZiAoY29udmVydFRvVHlwZSA9PT0gQ09MT1JfVFlQRVNbXCJPYmplY3RcIl0pIHJldHVybiByZ2JUb09iaih2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZ2IgdG8gcmdiLlxyXG4gICAgICAgICAgICBjb25zdCBvYmogPSByZ2JUb09iaih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpUb1JnYihvYmosIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTE9SX1RZUEVTW1wiT2JqZWN0XCJdKSB7XHJcbiAgICAgICAgICAgIGlmIChjb252ZXJ0VG9UeXBlLnN0YXJ0c1dpdGgoXCJoZXhcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqVG9IZXgodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoY29udmVydFRvVHlwZSA9PT0gQ09MT1JfVFlQRVNbXCJSR0JcIl0pIHJldHVybiBvYmpUb1JnYih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCB0eXBlIGZvciB0aGUgaW5wdXQgdmFsdWVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB3aGljaCBob2xkcyBzdGFydCBhbmQgZW5kIGNvbG9yIHZhbHVlcyBhbmQgY2FuIHByb2R1Y2UgYW55XHJcbiAgICAgKiBjb2xvciBiZXR3ZWVuIHRob3NlIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgY2xhc3MgQ29sb3JJbnRlcnBvbGF0b3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbG9ybWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGdldENvbG9yVHlwZShzdGFydCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gY29udmVydFRvKHN0YXJ0LCBDT0xPUl9UWVBFU1tcIk9iamVjdFwiXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCA9IGNvbnZlcnRUbyhzdG9wLCBDT0xPUl9UWVBFU1tcIk9iamVjdFwiXSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhbmdlUiA9ICt0aGlzLnN0b3BbXCJyXCJdIC0gK3RoaXMuc3RhcnRbXCJyXCJdO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmdlRyA9ICt0aGlzLnN0b3BbXCJnXCJdIC0gK3RoaXMuc3RhcnRbXCJnXCJdO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmdlQiA9ICt0aGlzLnN0b3BbXCJiXCJdIC0gK3RoaXMuc3RhcnRbXCJiXCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgY29sb3IgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIHN0b3AgY29sb3JzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBJZiBwcmVzZW50IHJldHVybiB0aGUgaW50ZXJwb2xhdGVkIGNvbG9yIGluIHRoaXMgZm9ybWF0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldENvbG9yKGZyYWN0aW9uLCB0eXBlID0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWN0aW9uICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBmcmFjdGlvbiAke2ZyYWN0aW9ufWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmcmFjdGlvbiA8IDAgfHwgZnJhY3Rpb24gPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgRnJhY3Rpb24gb3V0IG9mIHJhbmdlICR7ZnJhY3Rpb259YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHZhbHVlcyBiZXR3ZWVuIHRoZSBwcm92aWRlZCBzdGFydCBhbmQgZW5kIHZhbHVlcy5cclxuICAgICAgICAgICAgY29uc3QgciA9ICgrdGhpcy5zdGFydFtcInJcIl0gKyBmcmFjdGlvbiAqIHRoaXMucmFuZ2VSKSB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSAoK3RoaXMuc3RhcnRbXCJnXCJdICsgZnJhY3Rpb24gKiB0aGlzLnJhbmdlRykgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gKCt0aGlzLnN0YXJ0W1wiYlwiXSArIGZyYWN0aW9uICogdGhpcy5yYW5nZUIpIHwgMDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgIGcsXHJcbiAgICAgICAgICAgICAgICBiXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IG9iamVjdCB0byBlaXRoZXIgdGhlIG9yaWdpbmFsIG9yIHByb3ZpZGVkIGNvbG9yIHR5cGUuXHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG8oY29sb3JPYmosIHR5cGUgfHwgdGhpcy50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihzdGFydCwgZW5kLCBmcmFjdGlvbiwgdHlwZT1udWxsKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdG9yID0gbmV3IENvbG9ySW50ZXJwb2xhdG9yKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3IuZ2V0Q29sb3IoZnJhY3Rpb24sIHR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiBwdWJsaWMgQVBJLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZXhUb09iaixcclxuICAgICAgICBvYmpUb0hleCxcclxuICAgICAgICBvYmpUb1JnYixcclxuICAgICAgICBoZXhUb1JnYixcclxuICAgICAgICByZ2JUb0hleCxcclxuICAgICAgICBjb252ZXJ0VG8sXHJcbiAgICAgICAgQ29sb3JJbnRlcnBvbGF0b3JcclxuICAgIH07XHJcbn0pKCk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=